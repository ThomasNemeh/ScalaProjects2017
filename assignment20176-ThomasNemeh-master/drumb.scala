// Advanced Part 3 about a really dumb investment strategy
//==========================================================

object CW6c {


//two test portfolios

val blchip_portfolio = List("GOOG", "AAPL", "MSFT", "IBM", "FB", "YHOO", "AMZN", "BIDU")
val rstate_portfolio = List("PLD", "PSA", "AMT", "AIV", "AVB", "BXP", "CBG", "CCI", 
                            "DLR", "EQIX", "EQR", "ESS", "EXR", "FRT", "GGP", "HCP") 


// (1.a) The function below takes a stock symbol and a year as arguments.
//       It should read the corresponding CSV-file and read the January 
//       data from the given year. The data should be collected in a list of
//       strings for each line in the CSV-file.

import io.Source
import scala.util._

def get_january_data(symbol: String, year: Int) : List[String] = {
    val fileData = io.Source.fromFile(symbol + ".csv")
    val data = fileData.getLines().drop(1)
    val list = (for (line <- data if line.split("-")(0).toInt == year) yield line).toList
    fileData.close
    list
}

// (1.b) From the output of the get_january_data function, the next function 
//       should extract the first line (if it exists) and the corresponding
//       first trading price in that year as Option[Double]. If no line is 
//       generated by get_january_data then the result is None


def get_first_price(symbol: String, year: Int) : Option[Double] = {
  val dataList = get_january_data(symbol, year)
  if (dataList.isEmpty) None
  else Some(dataList(0).split(",")(1).toDouble)
}


// (1.c) Complete the function below that obtains all first prices
//       for the stock symbols from a portfolio (list of strings) and 
//       for the given range of years. The inner lists are for the
//       stock symbols and the outer list for the years.


def get_prices(portfolio: List[String], years: Range) : List[List[Option[Double]]] = {
  for (n <- years.toList) yield get_year_prices(portfolio, n)
}

def get_year_prices(portfolio: List[String], year: Int) : List[Option[Double]] = {
  for (p <- portfolio) yield get_first_price(p, year)
}


// (2) The first function below calculates the change factor (delta) between
//     a price in year n and a price in year n + 1. The second function calculates
//     all change factors for all prices (from a portfolio). The input to this
//     function are the nested lists created by get_prices above.

def get_delta(price_old: Option[Double], price_new: Option[Double]) : Option[Double] = {
  if (price_old.isDefined & price_new.isDefined) Some((price_new.get - price_old.get) / price_old.get)
  else None
}

def get_deltas(data: List[List[Option[Double]]]) :  List[List[Option[Double]]] = {
  for (n <- (0 to data.size - 2).toList) yield get_year_deltas(data, n)
}

def get_year_deltas(data: List[List[Option[Double]]], year: Int) : List[Option[Double]] = {
  for (n <- (0 to data(year).size - 1).toList) yield get_delta(data(year)(n), data(year + 1)(n))
}


// (3) Write a function that given change factors, a starting balance and a year
//     calculates the yearly yield, i.e. new balance, according to our dump investment 
//     strategy. Another function calculates given the same data calculates the
//     compound yield up to a given year. Finally a function combines all 
//     calculations by taking a portfolio, a range of years and a start balance
//     as arguments.


def yearly_yield(data: List[List[Option[Double]]], balance: Long, year: Int) : Long = {
  val yearList = data(year).flatten
  if (yearList.size == 0) balance
  else {
    val investmentUnit = balance.toDouble / yearList.size.toDouble
    stock_yields(yearList, investmentUnit).sum.toLong + balance
  }
}

def stock_yields(stocks: List[Double], investmentUnit: Double) : List[Double] = {
  for (n <- stocks) yield investmentUnit * n
}


def compound_yield(data: List[List[Option[Double]]], balance: Long, year: Int) : Long = {
  compound_yield_recursion(data, balance, year, 0)
}

def compound_yield_recursion(data: List[List[Option[Double]]], balance: Long, year: Int, yearCount: Int) : Long = {
  if (yearCount == year + 1) balance
  else {
    compound_yield_recursion(data, yearly_yield(data,balance,yearCount), year, yearCount + 1)
  }
  
}

def investment(portfolio: List[String], years: Range, start_balance: Long) : Long = {
  val data = get_deltas(get_prices(portfolio, years))
  compound_yield(data, start_balance, data.size - 1)
}


//test cases for the two portfolios given above

//investment(rstate_portfolio, 1978 to 2017, 100)
//investment(blchip_portfolio, 1978 to 2017, 100)

}
